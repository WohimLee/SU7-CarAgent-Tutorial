## 整体框架
### 1. 整体多 Agent 架构思路

针对车载助手，你大致会有这几类需求：
- 问“用户手册类问题” → RAG 解析
- 问“车况 / 设备状态 / 导航等” → 工具调用 & 实时系统
- 复杂任务（“帮我从上海开到杭州，顺便找一条不堵的风景路线，还要控制空调…”） → 需要任务分解 + 多轮工具调用 + 计划执行

在 LangGraph 里比较自然的思路是：一个 Orchestrator（总控 Agent） + 多个专才子 Agent（子图）

可以大致这样分层：

##### 顶层：Orchestrator Graph

- 判断用户意图
- 选择子图（“手册问答”、“车辆控制”、“导航规划”、“综合多轮任务”等）

##### 中层：功能子图（Subgraph）

- 手册 RAG 子图
- 车辆状态 & 控制子图（调你自己的 CAN/网关接口、车机 API）
- 导航 / 地图子图
- 问题澄清 / 多轮任务规划子图

##### 底层：工具节点 & 数据访问节点

- Redis / MySQL / Milvus / ES 的读写
- 第三方 API 调用（地图、TTS等）

>LangGraph 的优势：
- 每个子图可以是一个独立的小 workflow
- 用 conditional edges 分流
- 用 checkpointer 管整条图的 state（记忆、对话、工具结果）

### 2. Agent 角色划分建议

可以先规划 4–6 个核心 Agent（每个 Agent 在实现上可以对应 LangGraph 的一个节点或一组节点/子图）：

#### 2.1 Orchestrator / Router Agent（对话总控）

##### 职责

- 解析用户当前意图：
    - 手册问答？
    - 车辆状态/控制？
    - 导航相关？
    - 多步任务（涉及多个领域）？
- 决定调用哪个子图：
    - manual_rag_subgraph
    - vehicle_control_subgraph
    - navigation_subgraph
    - task_planner_subgraph
- 控制对话风格（安全、驾驶场景下尽量简洁）

##### 在 LangGraph 的实现要点

这是一个 LLM 节点 + 条件边：LLM 输出一个 structured output，例如：
```py
{
  "intent": "manual_faq", 
  "domain": "air_conditioning",
  "need_clarification": false
}
```
用 intent 字段决定走哪条边

#### 2.2 Manual RAG Agent（手册问答专家）

##### 职责

- 理解与车辆功能、按钮、告警灯等相关的问答
- 对接 RAG Pipeline，从多个存储中找内容
- 控制回答风格：
    - 首句直接结论
    - 后面再给操作步骤 / 安全警告

##### 内部可拆成一个子图

>Query Normalizer Node
- 将用户问题转成 “RAG-friendly” 查询（补全车型、年款、模块），可用 LLM 做 paraphrase 和补全。

>Retriever Node(s)
- 访问 Milvus / ES / Redis 等向量 / 倒排
- 聚合结果（去重、按得分排序）

>Rerank & Filter Node（可选）
- 用 LLM 或轻量模型做重排/过滤

>Answer Synthesizer Node

- 基于检索到的文档做回答
- 严格约束不瞎编（给出“手册中暂无相关内容”）

LangGraph 里，可以把这整套 RAG 流程包装成一个 Subgraph：
- 对外只有一个入口（输入：问题 + 对话上下文）
- 一个出口（输出：回答 + 引用文档 ID / 段落信息）

#### 2.3 Vehicle Control / Status Agent（车况与控制）

##### 职责

- 查询当前车况：油量、电量、胎压、门窗状态、空调状态……
- 下发控制指令：开空调、调温度、开/关车窗、切换驾驶模式等
- 需要严控安全（不能在高速中建议关车的关键系统）

##### LangGraph 设计

该 Agent 通常也是个子图：
- Safety Guard Node：
    - LLM/规则判断当前意图是否安全/允许
    - 否则拒绝或要求确认（“为了安全，我不能在行驶中关闭发动机。”）
- State Query Node：调用你们车机的状态 API
- Command Executor Node：调用控制 API（有幂等保护、日志）
- Result Summarizer Node：将执行结果用自然语言反馈

可选：把 “读状态” 和 “写控制” 拆成两个 tool，Agent 用 “工具使用”模式来调用。

#### 2.4 Navigation / Route Agent（导航计划）

##### 职责

- 理解各种导航个性化需求：
    - “带我去最近的充电站”
    - “躲避拥堵，风景好一点的路”
- 调用地图 / 路况 API
- 与车辆导航系统对接（下发路径）

##### LangGraph 设计

一个小子图：
- nav_intent_parser（LLM 节点：地点、时间、偏好）
- nav_tool_node（地图/路线查询）
- nav_result_formatter（建议路线，自然语言 + 下发车机）

#### 2.5 Task Planner Agent（多步任务规划）

这个可以用在比较复杂的问题上，例如：
- “我明天要去外地，帮我看看车况、规划路线、告诉我需要注意些什么。”

##### 职责

- 将复杂需求分解成多个子任务：
- 检查车况 → 调用 Vehicle Control 子图（只查不控）
- 规划路线 → 调用 Navigation 子图
- 查找相关手册注意事项 → 调用 Manual RAG 子图
- 串联这些子任务的结果，再给出一个综合回答

##### LangGraph 实现

- 这部分适合用 LangGraph 的 agentic planning 思路：
- Planner Node：输出一串计划（JSON：步骤列表 + 每步需要的子图/工具）
- Executor Node：按计划调用不同子图，收集结果
- Monitor Node（可选）：检查计划执行中途是否需要修改（例如某一步失败）

#### 2.6 Safety / Policy Agent（安全 & 合规）

车载场景很敏感，建议加一个独立安全代理（或安全子图）：

- 对输出进行 Safety Filter：
    - 驾驶期间不允许给出分心的信息（比如长篇小说、复杂操作步骤可以简化成“路边安全停车后我再详细说”）
    - 对“关闭安全系统”、“破解限速”等危险请求拒绝回答
- 对输入做过滤：检测用户是不是在咨询危险/违法内容

可以做成一个统一的 post-processing subgraph，挂在整个图的最外层输出之前。

### 3. 如何用 LangGraph 的子图 / 条件边组合这些 Agent
#### 3.1 顶层主图结构（示意）

伪代码思路（语言随意，重点是结构）：
```py
# 节点
orchestrator = Node("orchestrator_llm")
manual_rag = Subgraph("manual_rag_subgraph")
vehicle_ctrl = Subgraph("vehicle_control_subgraph")
navigation = Subgraph("navigation_subgraph")
task_planner = Subgraph("task_planner_subgraph")
safety_guard = Subgraph("safety_guard_subgraph")

# 图
graph = StateGraph(state_type=... )

graph.add_node("orchestrator", orchestrator)
graph.add_node("manual_rag", manual_rag)
graph.add_node("vehicle_ctrl", vehicle_ctrl)
graph.add_node("navigation", navigation)
graph.add_node("task_planner", task_planner)
graph.add_node("safety_guard", safety_guard)

graph.set_entry_point("orchestrator")

# 条件边：根据 orchestrator 的输出 intent 跳转
graph.add_conditional_edges(
    "orchestrator",
    condition=lambda state: state.intent,
    edges={
      "manual_faq": "manual_rag",
      "vehicle_status_or_control": "vehicle_ctrl",
      "navigation": "navigation",
      "complex_task": "task_planner",
    }
)

# 子图执行完之后，统一走向安全过滤
for node in ["manual_rag", "vehicle_ctrl", "navigation", "task_planner"]:
    graph.add_edge(node, "safety_guard")

graph.set_finish_point("safety_guard")
```

子图内部再用各自的节点和条件边把 RAG 流程、工具调用串起来。

### 4. LangGraph 的 Checkpoint / Memory 使用思路

车载助手里 对话连续性 + 任务进度 很重要，LangGraph 的 Checkpointer 可以帮你：

#### 4.1 存什么 State

可以在全局 State 里放：

- 当前对话历史（可裁剪）
- 用户偏好：
    - 常用目的地、常用空调温度
    - 驾驶风格（激进/温和）
- 当前进行中的任务：
    - 当前导航任务（起点-终点-途经点）
    - 当前多步任务的执行进度（planner 的步骤列表 & 已完成步骤）

#### 4.2 Checkpointer 的实践建议

- 按 Session / 车机 ID 保存：key 可以是 session_id 或 vehicle_id + timestamp。
- 使用 Redis / DB 实现 Checkpointer：车载里 Redis 很常见，可以直接做 checkpointer backend。
- 分层 State：
    - dialog_state: 用于多轮对话
    - task_state: 用于长任务进度
    - user_profile: 用于偏好（可以持久化到 MySQL）

在 LangGraph 里，checkpointer 会在每一步执行后自动持久化 state。
你只需要设计好 State 的结构（比如用 Pydantic 模型），确保可序列化。

### 5. 多数据源（Redis / MySQL / Milvus / ES）的接入模式

这里建议你把“多数据源”抽象成“多个 Retriever/Tool”，不要直接在 LLM 里纠结实现逻辑。

#### 5.1 手册 RAG 中如何使用多个库

你有：

- 向量库：Milvus（主向量检索）+ Redis（热数据向量或 cache）
- 倒排搜索：Elasticsearch（全文搜索）
- 结构化数据：MySQL（车型/版本/配置等）

一种常用架构：

##### Router / Strategy Node（RAG 内部）

- 根据 query 类型决定策略：
    - “某个告警码 Pxxxx” → MySQL / ES
    - “怎么用自适应巡航” → 向量检索（Milvus + Redis）
- 或者简单粗暴：统一同时查多源，再融合。

##### 向量检索 Node（Milvus + Redis）

- 先查 Redis （最近用过的 / 高频段落）
- Miss 再查 Milvus

##### 全文检索 Node（ES）
- 用 query 或 query_string 检索，取 Top-K

##### 结构化查询 Node（MySQL）

例如根据车型、年份、配置查具体参数：轮胎尺寸、油箱容量等

通常做成工具：get_vehicle_spec(model, year, trim)

##### 融合 Node

把各个来源的结果按：

- 置信度
- 来源权重（手册原文优先，QA 次之）
- 与 query 的语义相似度

做一次合并 & 去重。

在 LangGraph 里，这些可以是几个 Tool Node 或 Function Node，然后 RAG 子图里按顺序/条件调用：
```
QueryNormalizer -> [VectorRetriever, ESRetriever, MySQLTool] -> FusionNode -> AnswerLLM
```
#### 5.2 工具调用风格

你可以让 Manual RAG Agent / Planner Agent 以“工具使用模式”工作：

##### LLM 负责决定

- 调哪个 retriever
- 填哪些参数

##### LangGraph 中每个 retriever / 数据源是一个 Tool Node：
- milvus_search_tool
- es_search_tool
- mysql_query_tool
- redis_cache_tool


### 6. 落地顺序

- 先实现单 Agent 单子图版的 RAG 问答（Manual RAG 子图）：
    - 接入 Milvus + ES + MySQL
    - 流程：Normalize → Multi-Retrieval → Fusion → Answer
- 把它包成 LangGraph 的一个 Subgraph。
- 新建 orchestrator 节点 + 条件边路由到 RAG 子图。
- 再增加 vehicle_control_subgraph + navigation_subgraph。
- 最后加 task_planner_subgraph 和 safety_guard_subgraph，做成完整多 Agent 系统。
- 用 Checkpointer 持久化 state，并逐步丰富对话记忆 & 用户偏好。